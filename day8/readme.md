# C++11新特性
## 1.long long类型
>long long 类型是C++ 11 中新定义的。
## 2.列表初始化
>作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用，而在此之前，这种初始化的形式仅在某些受限的场合下才能使用。
>注意：初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。
## 3.nullptr
>C++11新标准下，初始化指针最好使用nullptr。
>原因：因为C++会将0和NULL，这取决于编译器如何去定义NULL,有的会定义为(void*)0,有的会定义为0；C++不允许将void*隐式转换为其他类型，在C++重载时会发生混乱。如：
- ``` void foo(char*)```
- ``` void foo(int)    ```
- 如果NULL被定义为void* ,那么当编译 ```char* ch = NULL```时，当```foo(NULL)```时，此时NULL为0，会去调用```foo(int)```,从而发生混乱。
- 为解决问题，需要区分NULL和0，故使用nullptr代替NULL,nullptr的类型为nullptr,可以转换为任何指针和成员指针的类型，也可以进行相等或不等的比较。
## 4.constexpr变量
>C++11新标准规定，运行将变量声明为**constexpr**类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，并且必须用常量表达式初始化。
- **一般来说**：如果你认定变量时一个常量表达式，那就把它声明成constexpr类型。
> constexpr函数
- constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型和形参的类型都得是字面值类型，而且函数体中有且只有一条return语句。
- 执行constexpr函数时，编译器把对constexpr函数的调用替换成结果值。为了能在编译过程中随时展开，constexpr被隐式地指定为内联函数。
- **注意:**内联函数和constexpr函数的定义需要放在头文件中。**原因**:内联函数和constexpr可以在程序中多次定义。毕竟，编译器要想展开函数仅有声明是不够的，还需要函数的定义。不过，对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。
## 5.类型别名
>类型别名是一个名字，它是某种类型的同义词。使用类型别名的好处，可以让复杂的类型名字变简单明了，还有助于程序员使用该类型的真实目的。
## 6.auto类型说明符
>能让表达式代替我们去分析表达式所属的类型。
## 7.decltype类型指示符
>有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。
>这时，C++11引入了第二种类型说明符**decltype**,它的作用是**选择并返回操作数的数据类型**，在此过程中，编译器分析表达式并得到他的类型，却不计算实际表达式的值。
* 注意：decltype中如果是表达式，表达式的内容是解引用，则得到的类型为引用类型。**decltype((variable))**:得到的永远是引用类型,而**decltype(variable)**只有当variable本身是一个引用时才引用。
## 8.类内初始化
>C++11新标准规定，可以为成员变量提供一个**类内初始值**。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。
## 9.使用atuo或decltype缩写类型
允许编译器通过auto或decltype推断变量类型
## 10.范围for语句
```
    for( declaration: expression)
        statement
    其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。
```
